Легенда
Некий банк выполнил миграцию с одной БД на другую. В ходе миграции были частично сломаны некоторые ETL-процессы и частично утеряны некоторые данные. Вам предстоит это исправить.

Перечень технологий:
Реляционная СУБД: Oracle 12+ или PostgreSQL 13+;
Среда SQL разработки (одна из): SQL Develop; pgAdmin; DBeaver; HeidiSQL; FrogSQL;
Python7+, Java 8 и, по желанию, Scala;
Talend x (по желанию);
Virtual Box;
Ubuntu 19+;
Spark / PySpark;
Jupyter notebook (опционально).
Примечания:
Для комфортного выполнения зданий вам понадобиться компьютер со следующими минимальными требованиями: win 7 / win 10 / Linux; 4 ГБ ОЗУ; 4-х ядерный процессор.
Если у вы не обладаете устройством с подобными характеристиками – обратитесь к кураторам или организаторам УЦ. Вероятно, вам выделят компьютер в офисе (если вы в филиальном городе);
В первую очередь вам понадобиться реляционная СУБД. Это может быть Oracle или PostgreSQL. В идеале установить Oracle 21XE (локально), но можно и версии пониже. Вам нужно зарегистрироваться на сайте oracle.com (лучше под VPN), указав выдуманное название компании и «дальнюю» страну (это формальность) и почту (лучше gmail.com);
https://www.oracle.com/cis/database/technologies/xe-downloads.html
Видео инструкция по установке ораклового сервера:
https://www.youtube.com/watch?v=-BJgLNzSssg&list=LL&index=10
Текстовая статья по установке:
https://ithelpspb.blogspot.com/2020/12/oracle-database-19c-windows-server-2019.html

Если возникнут трудности с Oracle, то можно установить PostgreSQL 13 и pgAdmin;
https://www.enterprisedb.com/downloads/postgres-postgresql-downloads

Python лучше установить не ниже версии 3.7.
Java лучше установить не ниже 8-й версии, с более высокими версиями бывают проблемы при интерграции с различными инструментами, но это лишь предположение;
Не забудьте после установки Java / Python настроить системные переменные;
(*) Если вы имеете опыт работы с Linux-системами (например Ubuntu) и сможете установить туда Oracle или PostgreSQL и работать с БД – это будет плюсом для вас.

















Задание №1
В некотором банке внедрили новую frontend-систему для работы с клиентами, а так же обновили и саму базу данных. Большую часть данных успешно были перенесены из старых БД в одну новую централизованную БД.  Но в момент переключения со старой системы на новую возникли непредвиденные проблемы в ETL-процессе, небольшой период (конец 2017 начало 2018 года) так и остался в старой базе. Старую базу отключили, а не выгруженные данные сохранили в csv-файлы. Недавно банку потребовалось построить отчёт по 101 форме. Те данные что остались в csv-файлах тоже нужны. Загрузить их в новую БД не получиться из-за архитектурных и управленческих сложностей, нужно рассчитать витрину отдельно. Но для этого сначала нужно загрузить исходные данные из csv-файлов в детальный слой (DS) хранилища в СУБД PostgreSQL.

 

Задача 1.1

Разработать ETL-процесс для загрузки «банковских» данных из csv-файлов в соответствующие таблицы СУБД PostgreSQL. Покрыть данный процесс логированием этапов работы и всевозможной дополнительной статистикой (на ваше усмотрение). Обратите внимание, что в разных файлах может быть разный формат даты, это необходимо учитывать при загрузке.

Исходные данные:
Файл «Структура таблиц.docx» – содержит описание и поможет создать таблицы в детальном слое DS
 

Краткое описание данных таблиц:

Таблицы DS.MD_ACCOUNT_D, DS.MD_CURRENCY_D и DS.MD_EXCHANGE_RATE_D содержат информацию о счетах, валютах и курсах валют соответственно. В данных таблицах есть поля data_actual_date и data_actual_end_date, по которым можно определить какие именно записи актуальны в нужную дату. Идентификаторы записей имеют окончание «_rk» (например, account_rk – идентификатор счета).

Таблица DS.MD_LEDGER_ACCOUNT_S – это справочник балансовых счетов. Он регулируется Центральным банком. По нему можно определить к какой главе и к каким разделам относятся счета первого (первые 3 цифры номера счета) и второго (первые 5 цифр номера счета) порядка.

Таблица DS.FT_POSTING_F – это таблица проводок (операций) в рабочем дне (поле oper_date), которая состоит из двух частей: счет дебета и счет кредита, которая изменяет баланс на сумму проводки

 

Требования к реализации задачи:
В своей БД создать пользователя / схему «DS».
Примеры команд:
https://postgrespro.ru/docs/postgresql/9.6/sql-createschema
Создать в DS-схеме таблицы под загрузку данных из csv-файлов.
Начало и окончание работы процесса загрузки данных должно логироваться в специальную логовую таблицу. Эту таблицу нужно придумать самостоятельно. По логам должно быть видно дату и время старта и окончания загрузки, так же можете туда добавить любую дополнительную информацию, которую посчитаете нужным.
После логирования о начале загрузки добавить таймер (паузу) на 5 секунд, чтобы чётко видеть разницу во времени между началом и окончанием загрузки. Из-за небольшого учебного объёма данных – процесс загрузки быстрый;
Для хранения логов нужно в БД создать отдельного пользователя / схему «LOGS» и создать в этой схеме таблицу для логов;
(В случае реализации процесса в Talend) В зависимости от мощностей рабочей станции – сделать загрузку из всех файлов одним потоком в параллели или отдельными потоками (может не хватить оперативной памяти для Java-heap);
Для корректного обновления данных в таблицах детального слоя DS нужно выбрать правильную Update strategy и использовать следующие первичные ключи для таблиц фактов, измерений и справочников (должно быть однозначное уникальное значение, идентифицирующее каждую запись таблицы):
Таблица

Первичный ключ

DS.FT_BALANCE_F

ON_DATE, ACCOUNT_RK

DS.FT_POSTING_F

У данной таблицы нет первичного ключа. Можно считать, что мы всегда в нее будем загружать полный набор данных, поэтому перед каждой загрузкой ее необходимо очищать.

DS.MD_ACCOUNT_D

DATA_ACTUAL_DATE, ACCOUNT_RK

DS.MD_CURRENCY_D

CURRENCY_RK, DATA_ACTUAL_DATE

DS.MD_EXCHANGE_RATE_D

DATA_ACTUAL_DATE, CURRENCY_RK

DS.MD_LEDGER_ACCOUNT_S

LEDGER_ACCOUNT, START_DATE

 

Технологические требования
ETL-процесс по загрузке файлов вы можете сделать с помощью различных технологий, которые вам будут удобней. Возможные варианты технологий:

Talend – бесплатная (для учебных целей) ETL-платформа;
Python – для данного языка существует множество библиотек, в том числе и для работы с базами данных и с различными файлами;
Java / Scala – для этих языков так же существует различные способы для работы с БД и файлами;
(*) Оркестрация процесса загрузки с помощью Airflow. Данный критерий не обязательный, но если вдруг вы сможете самостоятельно понять, установить и применить этот инструмент – это будет большим плюсом.
Требования к демонстрации работы:
Все скрипты и решения необходимо опубликовать в  github и предоставить ссылку на репозиторий. В случае работы в Talend выгрузите и прикрепите поток.
Записать видео с экрана компьютера, в котором вы демонстрируйте и комментируете в слух, то что вы делаете / уже разработали;
Нужно продемонстрировать создание или подробно прокомментировать разработанный вами поток (ETL-процесс);
Продемонстрировать, что поток работает – показать, что в таблице «DS.ft_balance_f» не было записей, потом запустить поток и показать, что таблица наполнилась;
Запись в таблицы должна выполняться в режиме «Запись или замена». Поэтому не забудьте определить ключевые поля для возможности обновлять информацию по уже существующим записям;
Продемонстрируйте как вы в файле «ft_balance_f.csv» меняете баланс для какого-нибудь <account_rk>, показываете что в таблице «DS.ft_balance_f» сперва была одна сумма у этого <account_rk> - потом запускаете ETL-процесс и показываете, что в таблице сумма обновилась;
Это видео загрузите к себе на облако (гугл-диск, яндекс-диск и т.п.) и предоставьте доступ по ссылке;
Приложите в репозиторий github текстовый файл с ссылкой на ваше видео
Примечания:
Если вы решили, что будете применять ETL-инструмент «Talend», то скачать можно отсюда:
https://drive.google.com/file/d/1EckjUqFFayFxVXjmyqSv75WY-joRFJE8/view?usp=drive_link

Для Talend обязательно понадобиться установить Java не ниже 8-й (jdk8.0);
Может оказаться так, что у вас в Talend не хватает каких-то элементов (например, таймер «tSleep») – значит вам нужно будет догрузить пакет дополнительных элементов. Talend сам об этом предложи;
Среды разработки для Python / Java / Scala можете использовать любые, какие вам удобны, главное, чтобы скрипт запускался и работал исправно;
Допустима трансформация csv-файла в excel-файл, если вам так будет удобней. 







Задача 1.2

После того как детальный слой «DS» успешно наполнен исходными данными из файлов – нужно рассчитать витрины данных в слое «DM»: витрину оборотов (DM.DM_ACCOUNT_TURNOVER_F) и витрину остатков (DM.DM_ACCOUNT_BALANCE_F). Структура и описание этих витрин находится в файле «Структура таблиц.docx». Вам необходимо их создать.

Начнем с витрины оборотов по лицевым счетам. Данная витрина содержит информацию по оборотам по лицевым счетам в рамках дня, когда были обороты. Вам будет необходимо создать процедуру расчета (назовите ее ds.fill_account_turnover_f), которая должна иметь один входной параметр – дату расчета (i_OnDate). Поля должны быть заполнены следующим образом:

on_date мы заполняем датой, за которую производим расчет (i_OnDate);

account_rk  - идентификатор счета, по которому были проводки в дату расчету;

credit_amount – сумма проводок (поле DS.FT_POSTING_F.credit_amount) за дату расчета (DS.FT_POSTING_F.oper_date = i_OnDate), где счет участвовал как счет по кредиту (DS.FT_POSTING_F.credit_account_rk);

credit_amount_rub – credit_amount из предыдущего пункта, умноженный на курс действующий за эту дату (курс хранится в поле ds.md_exchange_rate_d. reduced_cource). Если информации о курсе нет, то умножаем на единицу.

поля debet_amount и debet_amount_rub заполняем аналогично полям credit_amount и credit_amount_rub, только необходимо отбирать проводки, где счет участвовал как счет по дебету (DS.FT_POSTING_F.debet_account_rk) и необходимо брать сумму из поля DS.FT_POSTING_F.debet_amount.

Если по счету не было проводок в дату расчету, то он не должен попадать в витрину в эту дату. После создания процедуры рассчитайте данную витрину за каждый день января 2018 года.

Так как остатки за день считаются на основе остатков за предыдущий день, вам необходимо заполнить витрину DM.DM_ACCOUNT_BALANCE_F за 31.12.2017 данными из DS.FT_BALANCE_F. Поля on_date, account_rk, balance_out заполняются один в один, поле balance_out_rub заполняем как balance_out, умноженный на курс действующий за 31.12.2017. Если информации о курсе нет, то умножаем на единицу.

Затем необходимо создать процедуру заполнения витрины остатков по лицевым счетам. Назовите ее ds.fill_account_balance_f.  Данная процедура должна иметь один входной параметр – дату расчета (i_OnDate). Алгоритм заполнения следующий: необходимо взять все счета, действующие за дату расчета (дата расчета лежит между датами актуальности записей в таблице DS.MD_ACCOUNT_D), для этих счетов рассчитываем balance_out по следующему алгоритму:

·        для активных счетов (DS.MD_ACCOUNT_D.char_type = ‘А’): берем остаток в валюте счета за предыдущий день (если его нет, то считаем его равным 0), прибавляем к нему обороты по дебету в валюте счета (DM.DM_ACCOUNT_TURNOVER_F.debet_amount) и вычитаем обороты по кредиту в валюте счета  (DM.DM_ACCOUNT_TURNOVER_F.credit_amount) за этот день.

·        для пассивных счетов (DS.MD_ACCOUNT_D.char_type = ‘П’): берем остаток в валюте счета за предыдущий день (если его нет, то считаем его равным 0), вычитаем из него обороты по дебету в валюте счета и прибавляем обороты по кредиту в валюте счета  за этот день.

Поле balance_out_rub заполняем аналогично полю balance_out, но для расчета берем поля в рублях. Обратите внимание, что в какие-то дни по счету может не быть оборотов, но остаток по счету мы должны заполнить. После создания процедуры рассчитайте витрину остатков за каждый день января 2018 года.

В процедурах добавьте логирование на свое усмотрение. В качестве таблицы с логами можно использовать таблицу, созданную в задаче 1.1.  В логах должны быть информация о том какая витрина рассчитывается, дата и время старта и окончания расчета. Так же для возможности перезапускать расчет много раз за одни и те же даты, в процедурах в начале расчета вам необходимо удалять записи за дату расчета.

 

Требования к демонстрации работы:
Все скрипты и решения необходимо опубликовать в  github и предоставить ссылку на репозиторий.
Записать видео с экрана компьютера, в котором вы демонстрируйте и комментируете в слух, то что вы делаете / уже разработали;
Нужно продемонстрировать, как вы запускаете расчёт ежедневной витрины оборотов и витрины остатков за весь месяц и то как в витринах постепенно начинают появляться данные за разные дни Января;
Обязательно продемонстрируйте процесс логирования, который присутствует внутри процедур. Покажите, как при запуске расчёта витрины в логовой таблице появилась новая информация. Расскажите на видео почему выбрали именно такой вариант логирования.
Это видео загрузите к себе на облако (гугл-диск, яндекс-диск и т.п.) и предоставьте доступ по ссылке;
Приложите в репозиторий github текстовый файл с ссылкой на ваше видео
 

 Доступно с 26 июня 2025, 14:00
 
 
 
 
 
 
 Задача 1.3

После того как в предыдущих заданиях вы загрузили необходимую информацию и рассчитали витрины с оборотами и остатками, необходимо произвести расчет 101 формы за январь 2018 года. Структура и описание витрины по этой форме (DM.DM_F101_ROUND_F) находится в файле «Структура таблиц.docx». Вам необходимо ее создать.

101 форма содержит информацию об остатках и оборотах за отчетный период, сгруппированных по балансовым счетам второго порядка. Вам необходимо создать процедуру расчета (назовите ее dm.fill_f101_round_f), которая должна иметь один входной параметр – отчетную дату (i_OnDate). Отчетная дата – это первый день месяца, следующего за отчетным. То есть, если мы хотим рассчитать отчет за январь 2018 года, то должны передать в процедуру 1 февраля 2018 года. В отчет должна попасть информация по всем счетам, действующим в отчетном периоде, группировка в отчете идет по балансовым счетам второго порядка (балансовый счет второго порядка – это первые 5 символов номера счета (DS.MD_ACCOUNT_D.account_number). Поля витрины должны заполняться следующим образом:

FROM_DATE – первый день отчетного периода, TO_DATE – последний день отчетного периода;

CHAPTER – глава из справочника балансовых счетов (DS.MD_LEDGER_ACCOUNT_S);

LEDGER_ACCOUNT – балансовый счет второго порядка, CHARACTERISTIC – характеристика счета (можно получить из поля DS.MD_ACCOUNT_D.char_type);

BALANCE_IN_RUB – сумма остатков в рублях (DM.DM_ACCOUNT_BALANCE_F.balance_out_rub) за день, предшествующему первому дню отчетного периода (если отчет собирается за январь 2018 года, то это 31 декабря 2017 года), для рублевых счетов (рублевые счета, это те, у которых код валюты (поле DS.MD_ACCOUNT_D.currency_code равно 810 или 643));

BALANCE_IN_VAL – сумма остатков в рублях за день, предшествующему первому дню отчетного периода для всех счетов, кроме рублевых

BALANCE_IN_TOTAL - – сумма остатков в рублях за день, предшествующему первому дню отчетного периода для всех счетов;

TURN_DEB_RUB – сумма дебетовых оборотов в рублях (DM.DM_ACCOUNT_TURNOVER_F.debet_amount_rub) за все дни отчетного периода для рублевых счетов

TURN_DEB_VAL – сумма дебетовых оборотов в рублях за все дни отчетного периода для всех счетов, кроме рублевых;

TURN_DEB_TOTAL – сумма дебетовых оборотов в рублях за все дни отчетного периода для всех счетов

TURN_CRE_RUB – сумма кредитовых оборотов в рублях (DM.DM_ACCOUNT_TURNOVER_F.credit_amount_rub) за все дни отчетного периода для рублевых счетов;

TURN_CRE_VAL – сумма кредитовых оборотов в рублях за все дни отчетного периода для всех счетов, кроме рублевых;

TURN_CRE_TOTAL – сумма кредитовых оборотов в рублях за все дни отчетного периода для всех счетов

BALANCE_OUT_RUB – сумма остатков в рублях (DM.DM_ACCOUNT_BALANCE_F.balance_out_rub) за последний день отчетного периода для рублевых счетов;

BALANCE_OUT_VAL – сумма остатков в рублях за последний день отчетного периода для всех счетов, кроме рублевых;

BALANCE_OUT_TOTAL – сумма остатков в рублях за последний день отчетного периода для всех счетов

В процедуре расчета добавьте логирование на свое усмотрение. В качестве таблицы с логами можно использовать таблицу, созданную для предыдущих задач. В логах должна быть информация о том какая витрина рассчитывается, дата и время старта и окончания расчета. Так же для возможности перезапускать расчет много раз за одну и ту же дату, в процедурах в начале расчета вам необходимо удалять записи за дату расчета. Рассчитайте отчет за январь 2018 года.

Требования к демонстрации работы:
Все скрипты и решения необходимо опубликовать в  github и предоставить ссылку на репозиторий.
Записать видео с экрана компьютера, в котором вы демонстрируйте и комментируете в слух, то что вы делаете / уже разработали;
Покажите, как вы разработали процедуру расчёта 101-й формы и то как вы запускаете её расчёт и данные появляются в витрине;
Обязательно продемонстрируйте процесс логирования. Покажите, как при запуске расчёта витрины в логовой таблице появилась новая информация. Если сделали логирование по своему – расскажите на видео об этом. Можете прикрепить описания в виде текста – будет плюсом;
Это видео загрузите к себе на облако (гугл-диск, яндекс-диск и т.п.) и предоставьте доступ по ссылке;
Приложите в репозиторий github текстовый файл с ссылкой на ваше видео
 Доступно с 29 июня 2025, 14:00
 
 
 
 
 Задача 1.4

Выполнив предыдущие 2 задачи вам удалось рассчитать отчётную форму 101. Менеджер проекта доволен, ЦБ получил отчёт, руководство банка тоже довольно. Теперь необходимо выгрузить эти данные в формате, который бы позволил легко обмениваться ими между отделами. Один из таких форматов – CSV.

Напишите скрипт, который позволит выгрузить данные из витрины «dm. dm _f101_round_f» в csv-файл, первой строкой должны быть наименования колонок таблицы.

Убедитесь, что данные выгружаются в корректном формате и напишите скрипт, который позволит импортировать их обратно в БД. Поменяйте пару значений в выгруженном csv-файле и загрузите его в копию таблицы 101-формы «dm. dm _f101_round_f_v2».

Постарайтесь покрыть данные процессы простым логированием. Скрипты можно написать на Python / Scala / Java.

 

Требования к демонстрации работы:
Все скрипты и решения необходимо опубликовать в  github и предоставить ссылку на репозиторий.
Записать видео с экрана компьютера, в котором вы демонстрируйте и комментируете в слух, то что вы делаете / уже разработали;
Обязательно продемонстрируйте процесс экспорта и импорта данных с демонстрацией результата. Если есть процесс логирования, то тое продемонстрируйте его;
Это видео загрузите к себе на облако (гугл-диск, яндекс-диск и т.п.) и предоставьте доступ по ссылке;
Приложите в репозиторий github текстовый файл с ссылкой на ваше видео 
 Доступно с 01 июля 2025, 14:00
 
 
 
 
 
 
 
 
